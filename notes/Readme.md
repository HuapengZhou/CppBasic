# notes for the series
1. Welcome to C++
- Interact with hardware
- translate to machine code compared with Java (Virtural machine)
- faster
2. Set up C++ on windows
- IDE : visual studio
- set up the fonts stuff
3. Set up C++ on Mac
4. Set up C++ on linux
5. how C++ works
- preprocessor #include
- main function
- operator is just function
- Debug / Release
6. How the C++ compiler works
- compile + linking
7. How the C++ linker works
- find where the function is and link them together
- link error: cannot find the function is 
- static: just for this function
8. Varible in C++
- float 5.5f double 5.5
- sizeof()
9. functions in C++
10. head file
- #pragma once include the headfile only once
- avoid the chain of headfile
- #ifndef -> #define -> #endif
- include "" <> folder relative path and inside directory
11. How to debug C++ in Visual Studio
12. Conditions and branches in C++
13. Visual Studio Setup for C++ Projects miss
14. Loops in C++
15. Control Flow in C++
16. Pointer in C++
- 0 not valid address
- memset 
17. References in C++
- init immediately
- canot reference twice
18. Classes in C++
19. Class vs Structs
20. How to write a C++ class
21. static in C++
- only linke in this cpp file
- static variable and function
22. static for classes and struct
23. enums in C++
24. constructor in C++
25. Inheritance in C++
26. Virtual Functions in C++
- dynamic dispatch v tables
27. Interfaces in C++
- pure virtual function
28. Visibility
29. Arrays in C++
30. How Strings Work in C++
31. String Literals in C++
- can not concat together
32. CONST in C++
- mutable 
33. The Mutable Keyword in C++
- const function lamda function
34. member initializer lists
35. Ternary Operators in C++
36. How to create/instantiate objects in C++
37. The new keyword in C++
- new malloc + call the constructor
- delete free + call the destructor
38. Implicit conversion and the explicit keword
39. Operators & operator overloading
40. this keyword
41. Object lifetime in C++
42. smart pointers in C++
43. copy and copy constructor
44. arrow operation
45. std::vector
46. optimization of the usage of std::vector
47. local static in C++
48. using static libs in C++
49. using dynamic libs in C++
50. Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)
51. How to deal with multiple return values in C++
52. templates in C++
53. Stack vs Heap Memory in C++
54. Macros in C++
55. The auto keyword
56. std::array static array
57. function pointers
58. lambdas in C++
59. why I do not use namespace std
60. namespaces in C++
61. threads in C++
62. Timing in C++
63. Multidimensional Arrays
64. Sorting 
65. Type punning 
66. Unions in C++
67. Virtural destructor
68. Casting
69. Conditional and Action BreakPoints
70. safety
71. precompiled headers
72. dynamic casting
73. benchmarking
74. structured bindings
75. optional data
76. multiple types of data in a single variable
77. std::any
78. std::async
79. string faster
80. visual benchmarking 
81. singleton
82. small string optimization
83. track memory allocation
84. L and R value
85. CI
86. static analysis
87. argument evaluation
88. move semantics
89. std::move
